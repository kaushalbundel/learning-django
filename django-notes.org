#+title: Notes

* Steps to create a Django Project

1. create a virtual environment
2. install django in the virtual environment
3. create a project using django-admin utility
   1. This will create a directory structure that will be the basis of the project
4. Navigate to the project folder and create an app using manage.py utility
   1. This will create a folder structure that contains all the files and folders needed to run that specific app

#+begin_quote
Difference between project and app?

An app corresponds to a web application that does something. A project consists of an app in addition with the configurations that will enable that app. A project can contain more than one app and an app can be in multiple projects.

#+end_quote

* How URLs and Views Work Together
1. URL Routing:
When a user visits a URL, Django looks for a match in the urlpatterns list of the project’s urls.py file. If a match is found, Django routes the request to the corresponding app-level urls.py file if include() is used.
2. URL Matching:
In the app-level urls.py file, Django again looks for a match in the urlpatterns list. If a match is found, the corresponding view function is called.
3. View Execution:
The view function is executed, receiving the HTTP request as an argument. The view processes the request, interacts with models if necessary, and returns an HTTP response.
4. Response Delivery:
The HTTP response generated by the view is sent back to the user’s browser, rendering the content defined in the response.

* Database
sqlite is used as it comes built in with python but for production oriented usecases other databases are preferred. Both Relational as well as Non relational databases can be used with Django.

* Django Models
In Django, a model is a Python class that represents a database table and defines the structure of the table through its fields. Models are the backbone of Django’s ORM, allowing developers to interact with the database using Python code. The django.contrib.contenttypes framework enhances the flexibility of models by enabling generic relationships, allowing a model to reference any other model dynamically.

* Date: <2024-05-27 Mon>

** Database setup in Django

- manage.py file contains all the setting related to the project. It also includes some built
  in common apps. These apps can be enabled or disabled as per need.
- We can use the migrate command in sync with manage.py to create corresponding database tables for the mentioned apps in manage.py file

** Models in Django

- Models in Django are essentially representatives of the columns in a database. Like in relational database we define what the size of a column, the attributes of a column and most essentially the database table, we define the same attributes here in the classes in the form of python code
- Django provides models class as a super class for creating models (ie tables and attributes of tables ie. the columns)

#+begin_src python

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")

#+end_src
- In the above code block, the parent class is models.Model and Question class inherits the parent class. question_text and pub_date are the attributes of the Question class that are nothing but instances of the model.charField class with the property that the length of the CharField is 200 characters long.
- pub_date is defined similarly except one difference. The column name will be the name of the attribute defined ie. question_text or pub_date. The model names/column names should be easily comprehended. The attribute question_text has this property but the same can not be said about pub_date. To make this comprehensible Django model class has an optional property of name definition. "date published" is exactly that property.

* Date: <2024-05-28 Tue>

** The django tutorial gives different method for creating choices (which seems less intuitive to me.). Instead I can use the below method:
To create a Choice object based on a Question object in the Django shell, you need to follow these steps:

	1.	Define the Models:
First, ensure you have defined your Question and Choice models correctly, with Choice having a foreign key to Question.

# models.py
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

    def __str__(self):
        return self.question_text

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text


	2.	Open the Django Shell:
Navigate to your project directory and open the Django shell:

python manage.py shell


	3.	Import the Models:
Import the Question and Choice models in the shell:

from yourapp.models import Question, Choice


	4.	Create a Question Object:
Create a new Question object. For example:

question = Question.objects.create(question_text="What's new?", pub_date="2024-05-26")


	5.	Create a Choice Object:
Create a Choice object and associate it with the Question object you just created. You can do this by assigning the Question object to the question field of the Choice object:

choice = Choice.objects.create(question=question, choice_text="Not much", votes=0)



Example Step-by-Step

Here is a complete example showing how to create a Question and associated Choice object in the Django shell:

	1.	Start the Django shell:

python manage.py shell


	2.	Import the models:

from yourapp.models import Question, Choice


	3.	Create a Question object:

question = Question.objects.create(question_text="What's your favorite color?", pub_date="2024-05-26")


	4.	Create Choice objects associated with the Question:

choice1 = Choice.objects.create(question=question, choice_text="Blue", votes=0)
choice2 = Choice.objects.create(question=question, choice_text="Green", votes=0)
choice3 = Choice.objects.create(question=question, choice_text="Red", votes=0)


	5.	Verify the objects:

# List all questions
questions = Question.objects.all()
for q in questions:
    print(q.id, q.question_text, q.pub_date)

# List all choices for the created question
choices = Choice.objects.filter(question=question)
for c in choices:
    print(c.id, c.choice_text, c.votes)



This process will create a Question object and multiple Choice objects associated with it through the foreign key relationship. This approach ensures that each Choice is correctly linked to a Question in the database.

* <2024-05-29 Wed>

** Admin Login

- for the model to appear on the admin section, one must register the model in the <app>/admin.py page. After registeration the model details will appear there.

** What is actually happening right now, when a url like http://127.0.0.1:8000/polls/2/vote/ is being hit?

- first of all, the url gets searched in the app urls file(in this case: mysite/url). If the pattern get matched (like in this case it is /polls/) then another url gets checked
- This time the url is being checked from polls/url.py file. The pattern is matched and the url up the desired pattern gets thrown out (eg. http://127.0.0.1:8000/polls/ gets thrown out). The remaining url pattern is matached against the url patterns specified in the poll/url file. In this case the matched view is path("<int:question_id>/vote/", view=views.vote, name="vote")
- This url path is considered and view corresponding to the path is referenced for display on the frontend. Here the view is:
  def vote(request, question_id):
    return HttpResponse(f"You're voting on question {question_id}")
 This specific view is now displayed on the frontend.

** Template

A template is the frontend information. It constitutes HTML, CSS and JS.

** Views: Details

- A view does only and only two things, returning a HTMLResponse object (this contains the content of the requested page) or return a 404 error (Page not found error).
- If we actually want to render a template with the help of views, then we will need a place to store a template, and reference the same in the views where it will be needed.
- Generally, we will have to create an additional directory where the template will be stored. The default location for that directory is in the app, where all such templates will be stored. The default location of the template is <app_name>/templates/<app_name>/<template_name>like<index.html>
- The additional namespacing (extending the path by using app_name/template_name) is done so that we can reference the template directly by using <app_name>/<template_name>. This also helps in the situation where there are multiple apps with multiple template having similar name.

* <2024-05-30 Thu>

** Templates in Django

- The way to access models in templates is using "dot lookup syntax". This is similar to how attributes and methods are accessed in classes (OOPS).
- In the example shown in the tutorial, choice_set is the key work for selecting all the related foreign key options (choices corresponding to the questions as per defined in the model)
- choice_set populates the options related to the foreign key
- An alternate way and in my opinion a more convinient way to handle this specific use case:
  - question.choice_set.all: This expression retrieves all Choice objects that are related to the question
  - The for loop iterates over each Choice object in the choice_set and renders its choice_text and votes.

Why choice_set?

The name choice_set is derived from Django’s naming convention for related objects:

	•	choice: The name of the related model in lowercase.
	•	_set: A suffix added to denote that it is a collection of related objects.

Custom Related Name

You can customize this related name by using the related_name parameter in the ForeignKey field. This can make your code more readable and intuitive.

# models.py
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE, related_name='choices')
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

# template
<!-- question_detail.html -->
<h1>{{ question.question_text }}</h1>
<ul>
  {% for choice in question.choices.all %}
    <li>{{ choice.choice_text }} - Votes: {{ choice.votes }}</li>
  {% endfor %}
</ul>

- It is important to not hardcode urls in templates. The major disadvantage is that once the url has been hardcodes and if changes in url is required then the template file will have to be changed. Since a template file contains too many elements, this could get messy. The simpler solution here is to access the name attribute as mentioned in the <app_name>/urls.py file and use that to build the url. After that if the url needs to be changed, then we just need to update the corresponding path of the respective name attribute

- Now what would happen if there are multiple app, each have their own detail views. How will the template recognize the appropriate views to display. To do that Django provides namespacing.

*** TODO In the index.html template, we have mentioned latest_question_list in the tags, where are we populating this from? I am not able to understand this as latest_question_list is a argument in index view function. By all purposes, this should not have resulted returns as its scope is locally limited to index view.
